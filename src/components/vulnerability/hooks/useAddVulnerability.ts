import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useToast } from '@/hooks/use-toast';
import { useAuth } from '@/context/AuthContext';
import { VulnerabilityFormData } from '../types/vulnerability.types';
import { vulnerabilitiesApi } from '@/utils/api';

export const useAddVulnerability = (projectId: string, vulnId?: string) => {
  const [loading, setLoading] = useState(false);
  const { toast } = useToast();
  const navigate = useNavigate();
  const { user } = useAuth();

  const saveVulnerability = async (data: VulnerabilityFormData) => {
    try {
      setLoading(true);
      console.log('[useAddVulnerability] Saving vulnerability for project:', projectId);
      
      // Check if this is a temporary project (starts with temp_)
      const isTemporaryProject = projectId.startsWith('temp_');
      
      if (isTemporaryProject) {
        console.log('[useAddVulnerability] Handling temporary project vulnerability');
        // Handle temporary project vulnerability storage in localStorage
        const tempVulnId = vulnId || 'temp_vuln_' + Date.now().toString(36) + Math.random().toString(36).substring(2);
        
        // Prepare vulnerability data with required fields
        const vulnerabilityData: VulnerabilityFormData = {
          ...data,
          id: tempVulnId,
          report_id: projectId,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
          created_by: user?.id || 'unknown',
          current_status: data.current_status || false,
          display_order: 0
        };
        
        // Get existing vulnerabilities for this project - Using consistent key format
        const storageKey = `tempVulnerabilities_${projectId}`;
        console.log('[useAddVulnerability] Storage key being used:', storageKey);
        const existingVulnsJSON = localStorage.getItem(storageKey);
        const existingVulns = existingVulnsJSON ? JSON.parse(existingVulnsJSON) : [];
        
        console.log('[useAddVulnerability] Existing vulnerabilities:', existingVulns.length);
        
        if (vulnId && existingVulnsJSON) {
          // Update existing vulnerability
          console.log('[useAddVulnerability] Updating existing vulnerability:', vulnId);
          const updatedVulns = existingVulns.map((vuln: any) => {
            if (vuln.id === vulnId) {
              return {
                ...vuln,
                ...vulnerabilityData,
                updated_at: new Date().toISOString()
              };
            }
            return vuln;
          });
          localStorage.setItem(storageKey, JSON.stringify(updatedVulns));
          console.log('[useAddVulnerability] Updated vulnerability in localStorage');
        } else {
          // Add new vulnerability
          console.log('[useAddVulnerability] Adding new vulnerability to localStorage');
          existingVulns.push(vulnerabilityData);
          localStorage.setItem(storageKey, JSON.stringify(existingVulns));
          console.log('[useAddVulnerability] Added new vulnerability to localStorage, total:', existingVulns.length);
          console.log('[useAddVulnerability] Saved vulnerabilities:', JSON.stringify(existingVulns));
        }
        
        toast({
          title: vulnId ? 'Vulnerability Updated' : 'Vulnerability Added',
          description: `Successfully ${vulnId ? 'updated' : 'added'} vulnerability to temporary project`,
        });
        
        navigate(`/projects/${projectId}`);
        return;
      }
      
      // Handle cloud project vulnerability storage
      if (vulnId) {
        // Update existing vulnerability
        const result = await vulnerabilitiesApi.update(vulnId, {
          ...data,
          report_id: projectId
        });

        if (!result.success) {
          throw new Error(result.error || 'Failed to update vulnerability');
        }

        toast({
          title: 'Vulnerability Updated',
          description: 'Successfully updated vulnerability',
        });
      } else {
        // Create new vulnerability
        const result = await vulnerabilitiesApi.create({
          ...data,
          report_id: projectId
        });

        if (!result.success) {
          throw new Error(result.error || 'Failed to create vulnerability');
        }

        toast({
          title: 'Vulnerability Added',
          description: 'Successfully added new vulnerability',
        });
      }

      navigate(`/projects/${projectId}`);
    } catch (error: any) {
      console.error('[useAddVulnerability] Error saving vulnerability:', error);
      toast({
        title: 'Error',
        description: error.message || 'Failed to save vulnerability',
        variant: 'destructive',
      });
    } finally {
      setLoading(false);
    }
  };

  return { loading, saveVulnerability };
};