
import { useState, useEffect } from 'react';
import { vulnerabilitiesApi } from '@/utils/api';
import { VulnerabilityFormData } from '../types/vulnerability.types';
import { Json } from '@/types/database.types';
import { isTemporaryProject, getTempVulnerabilities } from '@/utils/tempProjectUtils';

export const useVulnerabilityData = (reportId?: string, vulnId?: string) => {
  const [vulnerabilities, setVulnerabilities] = useState<VulnerabilityFormData[]>([]);
  const [formData, setFormData] = useState<VulnerabilityFormData | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (reportId) {
      fetchVulnerabilities();
    }
  }, [reportId]);

  useEffect(() => {
    if (vulnId && reportId) {
      fetchSingleVulnerability();
    }
  }, [vulnId, reportId]);

  const fetchVulnerabilities = async () => {
    if (!reportId) return;

    try {
      setLoading(true);
      setError(null);
      
      // Handle temporary projects
      if (isTemporaryProject(reportId)) {
        const tempVulns = getTempVulnerabilities(reportId);
        setVulnerabilities(tempVulns);
        setLoading(false);
        return;
      }
      
      const result = await vulnerabilitiesApi.getByReportId(reportId);
      
      if (result.success && result.data) {
        // Transform the data to match VulnerabilityFormData interface
        const transformedData: VulnerabilityFormData[] = result.data.map(vuln => ({
          ...vuln,
          affected_versions: Array.isArray(vuln.affected_versions) 
            ? vuln.affected_versions as any[]
            : vuln.affected_versions 
              ? [vuln.affected_versions] 
              : [],
          ref_links: Array.isArray(vuln.ref_links) 
            ? (vuln.ref_links as Json[]).map(link => typeof link === 'string' ? link : String(link))
            : [],
          poc_images: Array.isArray(vuln.poc_images) 
            ? (vuln.poc_images as Json[]).map(img => {
                if (typeof img === 'object' && img !== null && 'name' in img) {
                  return img as { name: string; data: string; content_type: string; label?: string; };
                }
                return { name: 'image', data: String(img), content_type: 'image/jpeg' };
              })
            : [],
          retest_images: Array.isArray(vuln.retest_images) 
            ? (vuln.retest_images as Json[]).map(img => {
                if (typeof img === 'object' && img !== null && 'name' in img) {
                  return img as { name: string; data: string; content_type: string; label?: string; };
                }
                return { name: 'image', data: String(img), content_type: 'image/jpeg' };
              })
            : [],
          request_response: vuln.request_response || {}
        }));
        
        setVulnerabilities(transformedData);
      } else {
        throw new Error(result.error || 'Failed to fetch vulnerabilities');
      }
    } catch (err) {
      console.error('Error fetching vulnerabilities:', err);
      setError(err instanceof Error ? err.message : 'Failed to fetch vulnerabilities');
    } finally {
      setLoading(false);
    }
  };

  const fetchSingleVulnerability = async () => {
    if (!vulnId) return;

    try {
      setLoading(true);
      setError(null);
      
      const result = await vulnerabilitiesApi.getById(vulnId);
      
      if (result.success && result.data) {
        // Transform the data to match VulnerabilityFormData interface
        const transformedData: VulnerabilityFormData = {
          ...result.data,
          affected_versions: Array.isArray(result.data.affected_versions) 
            ? result.data.affected_versions as any[]
            : result.data.affected_versions 
              ? [result.data.affected_versions] 
              : [],
          ref_links: Array.isArray(result.data.ref_links) 
            ? (result.data.ref_links as Json[]).map(link => typeof link === 'string' ? link : String(link))
            : [],
          poc_images: Array.isArray(result.data.poc_images) 
            ? (result.data.poc_images as Json[]).map(img => {
                if (typeof img === 'object' && img !== null && 'name' in img) {
                  return img as { name: string; data: string; content_type: string; label?: string; };
                }
                return { name: 'image', data: String(img), content_type: 'image/jpeg' };
              })
            : [],
          retest_images: Array.isArray(result.data.retest_images) 
            ? (result.data.retest_images as Json[]).map(img => {
                if (typeof img === 'object' && img !== null && 'name' in img) {
                  return img as { name: string; data: string; content_type: string; label?: string; };
                }
                return { name: 'image', data: String(img), content_type: 'image/jpeg' };
              })
            : [],
          request_response: result.data.request_response || {}
        };
        
        setFormData(transformedData);
      } else {
        throw new Error(result.error || 'Failed to fetch vulnerability');
      }
    } catch (err) {
      console.error('Error fetching vulnerability:', err);
      setError(err instanceof Error ? err.message : 'Failed to fetch vulnerability');
    } finally {
      setLoading(false);
    }
  };

  const createVulnerability = async (data: Partial<VulnerabilityFormData>) => {
    try {
      setError(null);
      
      const result = await vulnerabilitiesApi.create(data);
      
      if (result.success && result.data) {
        await fetchVulnerabilities(); // Refresh the list
        return { success: true, data: result.data };
      } else {
        throw new Error(result.error || 'Failed to create vulnerability');
      }
    } catch (err) {
      console.error('Error creating vulnerability:', err);
      const errorMessage = err instanceof Error ? err.message : 'Failed to create vulnerability';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    }
  };

  const updateVulnerability = async (id: string, data: Partial<VulnerabilityFormData>) => {
    try {
      setError(null);
      
      const result = await vulnerabilitiesApi.update(id, data);
      
      if (result.success) {
        await fetchVulnerabilities(); // Refresh the list
        return { success: true };
      } else {
        throw new Error(result.error || 'Failed to update vulnerability');
      }
    } catch (err) {
      console.error('Error updating vulnerability:', err);
      const errorMessage = err instanceof Error ? err.message : 'Failed to update vulnerability';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    }
  };

  const deleteVulnerability = async (id: string) => {
    try {
      setError(null);
      
      const result = await vulnerabilitiesApi.delete(id);
      
      if (result.success) {
        await fetchVulnerabilities(); // Refresh the list
        return { success: true };
      } else {
        throw new Error(result.error || 'Failed to delete vulnerability');
      }
    } catch (err) {
      console.error('Error deleting vulnerability:', err);
      const errorMessage = err instanceof Error ? err.message : 'Failed to delete vulnerability';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    }
  };

  return {
    vulnerabilities,
    formData,
    loading,
    error,
    fetchVulnerabilities,
    createVulnerability,
    updateVulnerability,
    deleteVulnerability,
  };
};
