/**
 * Sanitize search term to prevent injection and ensure safe searching
 */
export const sanitizeSearchTerm = (term: string): string => {
  if (!term) return '';
  
  // Remove any HTML tags and trim whitespace
  // return term
  //   .replace(/<\/?[^>]+(>|$)/g, '')
  //   .trim();
  return term.replace(/<\/?[^>]+(>|$)/g, '');

};

/**
 * Format request/response data for display
 * Handles different input types and ensures consistent output
 */
export const formatRequestResponse = (requestResponse: any): string => {
  if (!requestResponse) return '';
  
  // If it's already a string, return it
  if (typeof requestResponse === 'string') return requestResponse;
  
  // If it's an object with request and response properties, format them
  if (requestResponse.request || requestResponse.response) {
    let result = '';
    
    if (requestResponse.request) {
      result += '=== REQUEST ===\n\n';
      result += requestResponse.request;
      result += '\n\n';
    }
    
    if (requestResponse.response) {
      result += '=== RESPONSE ===\n\n';
      result += requestResponse.response;
    }
    
    return result;
  }
  
  // Otherwise, try to stringify the object
  try {
    return JSON.stringify(requestResponse, null, 2);
  } catch (e) {
    return 'Invalid request/response data';
  }
};

/**
 * Ensure search results are visible by applying proper z-index
 * and background styling to dropdowns
 */
export const applyDropdownStyles = (element: HTMLElement | null): void => {
  if (!element) return;
  
  element.style.zIndex = '50';
  element.style.backgroundColor = 'var(--background)';
  element.style.boxShadow = '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)';
  element.style.borderRadius = '0.375rem';
  element.style.border = '1px solid var(--border)';
  element.style.width = '100%';
  element.style.maxHeight = '300px';
  element.style.overflowY = 'auto';
  element.style.position = 'absolute';
};

/**
 * Sort vulnerabilities by severity
 */
export const sortBySeverity = (vulnerabilities: any[]): any[] => {
  const SEVERITY_ORDER = {
    'critical': 1,
    'high': 2,
    'medium': 3,
    'low': 4,
    'info': 5
  };
  
  return [...vulnerabilities].sort((a, b) => {
    const severityA = a.severity as keyof typeof SEVERITY_ORDER;
    const severityB = b.severity as keyof typeof SEVERITY_ORDER;
    return SEVERITY_ORDER[severityA] - SEVERITY_ORDER[severityB];
  });
};

/**
 * Generate vulnerability ID based on project name, severity, and count
 */
export const generateVulnerabilityId = (
  projectName: string,
  severity: string,
  countInSameCategory: number
): string => {
  if (!projectName || !severity) return '';
  
  // Get project prefix (first 3 letters uppercase)
  const projectPrefix = projectName.substring(0, 3).toUpperCase();
  
  // Get severity prefix (first letter uppercase)
  const severityPrefix = severity.charAt(0).toUpperCase();
  
  // Format number with leading zero if needed
  const num = (countInSameCategory + 1).toString().padStart(2, '0');
  
  // Format: PREFIX.S.## (e.g., H4R.C.01)
  return `${projectPrefix}.${severityPrefix}.${num}`;
};

/**
 * Delete a vulnerability from the database
 */
export const deleteVulnerability = async (
  supabase: any,
  vulnerabilityId: string
): Promise<{ success: boolean; error?: string }> => {
  try {
    // Delete the vulnerability
    const { error } = await supabase
      .from('vulnerabilities')
      .delete()
      .eq('id', vulnerabilityId);
      
    if (error) throw error;
    
    return { success: true };
  } catch (error: any) {
    console.error('Error deleting vulnerability:', error);
    return { 
      success: false, 
      error: error.message || 'Failed to delete vulnerability' 
    };
  }
};

/**
 * Create a vulnerability in the database
 */
export async function createVulnerability(supabase: any, vulnerability: any, reportId: string) {
  try {
    const userId = (await supabase.auth.getUser()).data.user?.id;
    
    if (!userId) {
      throw new Error('User is not authenticated');
    }

    // Generate vulnerability_id if not provided and not marked as manual
    let vulnId = vulnerability.vulnerability_id || '';

    if (!vulnId && vulnerability._autoGenerateId !== false) {
      // Get project name to generate prefix
      const { data: projectData, error: projectError } = await supabase
        .from('reports')
        .select('title')
        .eq('id', reportId)
        .single();

      if (projectError) throw projectError;
      
      if (projectData) {
        // Get prefix from project name - first 3 chars uppercase
        const prefix = projectData.title.substring(0, 3).toUpperCase();
        
        // Get severity first letter
        const severityPrefix = vulnerability.severity.charAt(0).toUpperCase();
        
        // Count existing vulnerabilities with the same severity in this report
        const { data: countData, error: countError } = await supabase
          .from('vulnerabilities')
          .select('id')
          .eq('report_id', reportId)
          .eq('severity', vulnerability.severity);
          
        if (countError) throw countError;
        
        const count = (countData?.length || 0) + 1;
        
        // Format: PREFIX.S.## (e.g., H4R.C.01)
        vulnId = `${prefix}.${severityPrefix}.${count.toString().padStart(2, '0')}`;
      }
    }

    // Remove internal property
    if (vulnerability._autoGenerateId !== undefined) {
      delete vulnerability._autoGenerateId;
    }

    const { data, error } = await supabase.from('vulnerabilities').insert({
      title: vulnerability.title,
      description: vulnerability.description || '',
      severity: vulnerability.severity,
      cvss_score: vulnerability.cvss_score || 0,
      cvss_vector: vulnerability.cvss_vector || '',
      remediation: vulnerability.remediation || '',
      background: vulnerability.background || '',
      details: vulnerability.details || '',
      ref_links: vulnerability.ref_links || [],
      affected_versions: vulnerability.affected_versions || [],
      report_id: reportId,
      created_by: userId,
      vulnerability_id: vulnId,
      request_response: vulnerability.request_response || {},
      poc_images: vulnerability.poc_images || [],
    }).select().single();

    if (error) {
      throw error;
    }

    return { success: true, id: data.id };
  } catch (error: any) {
    console.error('Error creating vulnerability:', error);
    return { success: false, error: error.message || 'Unknown error' };
  }
}

/**
 * Update a vulnerability in the database
 */
export async function updateVulnerability(supabase: any, id: string, vulnerability: any) {
  try {
    // Keep the existing vulnerability ID if present and not manually changing
    const { data: existingVuln, error: fetchError } = await supabase
      .from('vulnerabilities')
      .select('vulnerability_id, report_id')
      .eq('id', id)
      .single();
      
    if (fetchError) throw fetchError;

    // Generate vulnerability_id if not already set and not marked for manual entry
    let vulnId = vulnerability.vulnerability_id || '';
    
    if (!vulnId && vulnerability._autoGenerateId !== false) {
      // Get project name to generate prefix
      const { data: projectData, error: projectError } = await supabase
        .from('reports')
        .select('title')
        .eq('id', existingVuln.report_id)
        .single();

      if (projectError) throw projectError;
      
      if (projectData) {
        // Get prefix from project name - first 3 chars uppercase
        const prefix = projectData.title.substring(0, 3).toUpperCase();
        
        // Get severity first letter
        const severityPrefix = vulnerability.severity.charAt(0).toUpperCase();
        
        // Count existing vulnerabilities with the same severity in this report
        const { data: countData, error: countError } = await supabase
          .from('vulnerabilities')
          .select('id')
          .eq('report_id', existingVuln.report_id)
          .eq('severity', vulnerability.severity);
          
        if (countError) throw countError;
        
        // Find position of this vulnerability in the same-severity list
        const sameTypeVulns = countData || [];
        let position = 1;
        
        for (let i = 0; i < sameTypeVulns.length; i++) {
          if (sameTypeVulns[i].id === id) {
            position = i + 1;
            break;
          }
        }
        
        // Format: PREFIX.S.## (e.g., H4R.C.01)
        vulnId = `${prefix}.${severityPrefix}.${position.toString().padStart(2, '0')}`;
      }
    } else if (existingVuln && existingVuln.vulnerability_id && vulnerability._autoGenerateId !== false) {
      // Keep existing ID if we're not changing it
      vulnId = existingVuln.vulnerability_id;
    }

    // Remove internal property
    if (vulnerability._autoGenerateId !== undefined) {
      delete vulnerability._autoGenerateId;
    }

    const { data, error } = await supabase.from('vulnerabilities').update({
      title: vulnerability.title,
      description: vulnerability.description || '',
      severity: vulnerability.severity,
      cvss_score: vulnerability.cvss_score || 0,
      cvss_vector: vulnerability.cvss_vector || '',
      remediation: vulnerability.remediation || '',
      background: vulnerability.background || '',
      details: vulnerability.details || '',
      ref_links: vulnerability.ref_links || [],
      affected_versions: vulnerability.affected_versions || [],
      vulnerability_id: vulnId,
      request_response: vulnerability.request_response || {},
      poc_images: vulnerability.poc_images || [],
      updated_at: new Date().toISOString(),
    }).eq('id', id).select().single();

    if (error) {
      throw error;
    }

    return { success: true, data };
  } catch (error: any) {
    console.error('Error updating vulnerability:', error);
    return { success: false, error: error.message || 'Unknown error' };
  }
}

/**
 * Duplicate a vulnerability in the database
 * Makes a copy with a new ID and "(Copy)" appended to the title
 */
export async function duplicateVulnerability(supabase: any, vulnerability: any): Promise<{ success: boolean; error?: string; id?: string }> {
  try {
    const userId = (await supabase.auth.getUser()).data.user?.id;
    
    if (!userId) {
      throw new Error('User is not authenticated');
    }

    // If we're duplicating using just the vulnerability ID
    if (typeof vulnerability === 'string' || !vulnerability.hasOwnProperty('id')) {
      const vulnId = typeof vulnerability === 'string' ? vulnerability : vulnerability.id;
      
      // Fetch the full vulnerability data first
      const { data: origVuln, error: fetchError } = await supabase
        .from('vulnerabilities')
        .select('*')
        .eq('id', vulnId)
        .single();
        
      if (fetchError) throw fetchError;
      
      // Use the fetched data for duplication
      vulnerability = origVuln;
    } else {
      // If we already have the full vulnerability object, fetch it to ensure we have the latest data
      const { data: origVuln, error: fetchError } = await supabase
        .from('vulnerabilities')
        .select('*')
        .eq('id', vulnerability.id)
        .single();
        
      if (fetchError) throw fetchError;
      
      vulnerability = origVuln;
    }

    // Generate a new vulnerability ID for the duplicate
    let vulnId = '';
    
    // Get project name to generate prefix
    const { data: projectData, error: projectError } = await supabase
      .from('reports')
      .select('title')
      .eq('id', vulnerability.report_id)
      .single();

    if (projectError) throw projectError;
    
    if (projectData) {
      // Get prefix from project name - first 3 chars uppercase
      const prefix = projectData.title.substring(0, 3).toUpperCase();
      
      // Get severity first letter
      const severityPrefix = vulnerability.severity.charAt(0).toUpperCase();
      
      // Count existing vulnerabilities with the same severity in this report
      const { data: countData, error: countError } = await supabase
        .from('vulnerabilities')
        .select('id')
        .eq('report_id', vulnerability.report_id)
        .eq('severity', vulnerability.severity);
        
      if (countError) throw countError;
      
      const count = (countData?.length || 0) + 1;
      
      // Format: PREFIX.S.## (e.g., H4R.C.01)
      vulnId = `${prefix}.${severityPrefix}.${count.toString().padStart(2, '0')}`;
    }

    // Create the duplicate with a new ID
    const { data, error } = await supabase.from('vulnerabilities').insert({
      title: `${vulnerability.title} (Copy)`,
      description: vulnerability.description || '',
      severity: vulnerability.severity,
      cvss_score: vulnerability.cvss_score || 0,
      cvss_vector: vulnerability.cvss_vector || '',
      remediation: vulnerability.remediation || '',
      background: vulnerability.background || '',
      details: vulnerability.details || '',
      ref_links: vulnerability.ref_links || [],
      affected_versions: vulnerability.affected_versions || [],
      report_id: vulnerability.report_id,
      created_by: userId,
      vulnerability_id: vulnId,
      request_response: vulnerability.request_response || {},
      poc_images: vulnerability.poc_images || [],
    }).select().single();

    if (error) {
      throw error;
    }

    return { success: true, id: data.id };
  } catch (error: any) {
    console.error('Error duplicating vulnerability:', error);
    return { success: false, error: error.message || 'Unknown error' };
  }
}
