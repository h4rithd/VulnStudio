
import React, { useState, useRef } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Trash2, Upload, Image, FileText, Paperclip, Eye } from 'lucide-react';
import { cn } from '@/lib/utils';
import { Dialog, DialogContent, DialogTitle, DialogHeader } from '@/components/ui/dialog';

interface Attachment {
  id?: string;
  name: string;
  label: string;
  data: string;
  content_type: string;
  vulnerability_id?: string;
}

interface AttachmentUploaderProps {
  attachments: Attachment[];
  onChange: (attachments: Attachment[]) => void;
}

const AttachmentUploader: React.FC<AttachmentUploaderProps> = ({ 
  attachments, 
  onChange 
}) => {
  const [dragActive, setDragActive] = useState(false);
  const [previewAttachment, setPreviewAttachment] = useState<Attachment | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  
  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files || e.target.files.length === 0) return;
    
    await handleFiles(Array.from(e.target.files));
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };
  
  const handleFiles = async (files: File[]) => {
    for (const file of files) {
      try {
        const reader = new FileReader();
        
        reader.onload = (event) => {
          if (event.target && typeof event.target.result === 'string') {
            const base64data = event.target.result;
            addAttachment(file.name, file.type, base64data);
          }
        };
        
        reader.readAsDataURL(file);
      } catch (error) {
        console.error("Error reading file:", error);
      }
    }
  };
  
  const addAttachment = (name: string, contentType: string, data: string) => {
    const newAttachment: Attachment = {
      name,
      label: `Figure ${attachments.length + 1}: ${name.split('.')[0]}`,
      data,
      content_type: contentType
    };
    
    onChange([...attachments, newAttachment]);
  };
  
  const removeAttachment = (index: number) => {
    const newAttachments = [...attachments];
    newAttachments.splice(index, 1);
    onChange(newAttachments);
  };
  
  const updateAttachmentLabel = (index: number, label: string) => {
    const newAttachments = [...attachments];
    newAttachments[index] = { ...newAttachments[index], label };
    onChange(newAttachments);
  };
  
  const handleDrag = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === "dragenter" || e.type === "dragover") {
      setDragActive(true);
    } else if (e.type === "dragleave") {
      setDragActive(false);
    }
  };
  
  const handleDrop = async (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      await handleFiles(Array.from(e.dataTransfer.files));
    }
  };
  
  const handlePaste = async (e: React.ClipboardEvent) => {
    if (e.clipboardData.files.length > 0) {
      await handleFiles(Array.from(e.clipboardData.files));
    }
  };
  
  const getFileIcon = (contentType: string) => {
    if (contentType.startsWith('image/')) {
      return <Image className="w-5 h-5" />;
    }
    return <FileText className="w-5 h-5" />;
  };

  const handlePreview = (attachment: Attachment) => {
    setPreviewAttachment(attachment);
  };
  
  const renderPreview = () => {
    if (!previewAttachment) return null;
    
    if (previewAttachment.content_type.startsWith('image/')) {
      return (
        <div className="flex items-center justify-center">
          <img 
            src={previewAttachment.data} 
            alt={previewAttachment.name}
            className="max-h-[500px] max-w-full object-contain" 
          />
        </div>
      );
    } 
    
    if (previewAttachment.content_type.startsWith('text/')) {
      // For text files, show the content
      const textContent = previewAttachment.data.split(',')[1];
      const decodedText = textContent ? atob(textContent) : '';
      return (
        <div className="bg-muted p-4 rounded overflow-auto max-h-[500px]">
          <pre className="text-sm whitespace-pre-wrap">{decodedText}</pre>
        </div>
      );
    }
    
    // For other file types, show a message
    return (
      <div className="text-center p-8">
        <FileText className="mx-auto h-16 w-16 text-muted-foreground mb-4" />
        <p>Preview not available for this file type.</p>
        <p className="text-sm text-muted-foreground">{previewAttachment.name}</p>
      </div>
    );
  };
  
  return (
    <div className="space-y-4">
      {/* Unified wide drag and drop area */}
      <div 
        className={cn(
          "border-2 border-dashed rounded-md p-6 cursor-pointer transition-colors w-full",
          dragActive 
            ? "border-primary bg-primary/10"
            : "border-muted-foreground/25 hover:border-primary/50"
        )}
        onClick={() => fileInputRef.current?.click()}
        onDragEnter={handleDrag}
        onDragOver={handleDrag}
        onDragLeave={handleDrag}
        onDrop={handleDrop}
        onPaste={handlePaste}
        tabIndex={0}
      >
        <div className="flex flex-col items-center justify-center space-y-2">
          <Upload className="w-8 h-8 text-muted-foreground" />
          <p className="text-sm font-medium">
            Drag & drop images here, <span className="text-primary">browse</span>, or paste from clipboard
          </p>
          <p className="text-xs text-muted-foreground">
            Supported formats: JPG, PNG, GIF, WEBP
          </p>
        </div>
        <Input
          ref={fileInputRef}
          type="file"
          accept="image/*"
          onChange={handleFileChange}
          multiple
          className="hidden"
        />
      </div>
      
      {/* Image preview grid */}
      {attachments.length > 0 && (
        <div className="space-y-2">
          <Label>PoC Images ({attachments.length})</Label>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {attachments.map((attachment, index) => (
              <div 
                key={attachment.id || index} 
                className="relative border rounded-md overflow-hidden group"
              >
                {attachment.content_type.startsWith('image/') ? (
                  <div className="aspect-video relative">
                    <img 
                      src={attachment.data} 
                      alt={attachment.label} 
                      className="object-cover w-full h-full"
                    />
                    <div className="absolute inset-0 bg-black/0 group-hover:bg-black/20 transition-colors flex items-center justify-center opacity-0 group-hover:opacity-100">
                      <Button
                        variant="secondary"
                        size="sm"
                        onClick={(e) => {
                          e.stopPropagation();
                          handlePreview(attachment);
                        }}
                        className="mr-2"
                      >
                        <Eye className="w-4 h-4" />
                      </Button>
                      <Button
                        variant="destructive"
                        size="sm"
                        onClick={(e) => {
                          e.stopPropagation();
                          removeAttachment(index);
                        }}
                      >
                        <Trash2 className="w-4 h-4" />
                      </Button>
                    </div>
                  </div>
                ) : (
                  <div className="p-4 flex items-center">
                    {getFileIcon(attachment.content_type)}
                    <span className="ml-2 truncate">{attachment.name}</span>
                  </div>
                )}
                <div className="p-2 border-t">
                  <Input
                    value={attachment.label}
                    onChange={(e) => updateAttachmentLabel(index, e.target.value)}
                    className="text-sm"
                    placeholder="Enter label"
                  />
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Preview Dialog */}
      <Dialog open={previewAttachment !== null} onOpenChange={(open) => !open && setPreviewAttachment(null)}>
        <DialogContent className="sm:max-w-3xl">
          <DialogHeader>
            <DialogTitle>{previewAttachment?.label || previewAttachment?.name}</DialogTitle>
          </DialogHeader>
          {renderPreview()}
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default AttachmentUploader;
