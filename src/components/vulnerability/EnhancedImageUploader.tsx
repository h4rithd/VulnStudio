import React, { useState, useRef, useCallback } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { ClipboardPaste, Upload, Image as ImageIcon, Square, Highlighter, Crop, X, Undo } from 'lucide-react';
import { cn } from '@/lib/utils';
import { useToast } from '@/hooks/use-toast';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Badge } from '@/components/ui/badge';

interface PocImage {
  name: string;
  data: string;
  content_type: string;
  label?: string;
}

interface EnhancedImageUploaderProps {
  images: PocImage[];
  onChange: (images: PocImage[]) => void;
  title: string;
  className?: string;
}

interface AnnotationTool {
  id: string;
  name: string;
  icon: React.ComponentType<any>;
  cursor: string;
}

const annotationTools: AnnotationTool[] = [
  { id: 'rectangle-white', name: 'White Rectangle', icon: Square, cursor: 'crosshair' },
  { id: 'rectangle-red', name: 'Red Rectangle', icon: Square, cursor: 'crosshair' },
  { id: 'rectangle-outline-red', name: 'Red Outline', icon: Square, cursor: 'crosshair' },
  { id: 'rectangle-outline-green', name: 'Green Outline', icon: Square, cursor: 'crosshair' },
  { id: 'blur', name: 'Blur Area', icon: Square, cursor: 'crosshair' },
  { id: 'highlight', name: 'Highlight', icon: Highlighter, cursor: 'crosshair' },
  { id: 'crop', name: 'Crop Image', icon: Crop, cursor: 'crop' },
];

const EnhancedImageUploader: React.FC<EnhancedImageUploaderProps> = ({
  images,
  onChange,
  title,
  className
}) => {
  const [dragActive, setDragActive] = useState(false);
  const [editingImageIndex, setEditingImageIndex] = useState<number | null>(null);
  const [selectedTool, setSelectedTool] = useState<string>('rectangle-red');
  const [isDrawing, setIsDrawing] = useState(false);
  const [startPoint, setStartPoint] = useState<{x: number, y: number} | null>(null);
  const [currentRect, setCurrentRect] = useState<{x: number, y: number, width: number, height: number} | null>(null);
  const [canvasHistory, setCanvasHistory] = useState<string[]>([]);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const imageRef = useRef<HTMLImageElement>(null);
  const overlayCanvasRef = useRef<HTMLCanvasElement>(null);
  const canvasContainerRef = useRef<HTMLDivElement>(null);
  const { toast } = useToast();

  const handleFiles = async (files: File[]) => {
    for (const file of files) {
      if (!file.type.startsWith('image/')) {
        toast({
          title: 'Invalid file type',
          description: 'Only image files are allowed',
          variant: 'destructive',
        });
        continue;
      }

      try {
        const reader = new FileReader();
        reader.onload = (e) => {
          if (!e.target?.result) return;
          
          const newImage: PocImage = {
            name: file.name,
            data: e.target.result as string,
            content_type: file.type,
            label: `Figure ${images.length + 1}: ${file.name.split('.')[0]}`
          };
          
          onChange([...images, newImage]);
          
          toast({
            title: 'Image added',
            description: `${file.name} has been added successfully`,
          });
        };
        reader.readAsDataURL(file);
      } catch (error) {
        console.error('Error reading file:', error);
        toast({
          title: 'Error',
          description: 'Failed to read file',
          variant: 'destructive',
        });
      }
    }
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      handleFiles(Array.from(e.target.files));
    }
    e.target.value = '';
  };

  const handleDrag = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === "dragenter" || e.type === "dragover") {
      setDragActive(true);
    } else if (e.type === "dragleave") {
      setDragActive(false);
    }
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      handleFiles(Array.from(e.dataTransfer.files));
    }
  };

  const handlePaste = useCallback((e: React.ClipboardEvent | ClipboardEvent) => {
    const items = e.clipboardData?.items;
    if (!items) return;

    for (let i = 0; i < items.length; i++) {
      if (items[i].type.indexOf('image') !== -1) {
        const file = items[i].getAsFile();
        if (file) {
          handleFiles([file]);
        }
      }
    }
  }, [images, onChange]);

  const removeImage = (index: number) => {
    const newImages = [...images];
    newImages.splice(index, 1);
    onChange(newImages);
  };

  const updateImageLabel = (index: number, label: string) => {
    const newImages = [...images];
    newImages[index] = { ...newImages[index], label };
    onChange(newImages);
  };

  const openImageEditor = (index: number) => {
    setEditingImageIndex(index);
    setCanvasHistory([]);
    console.log('Opening image editor for index:', index);
  };

  const closeImageEditor = () => {
    setEditingImageIndex(null);
    setSelectedTool('rectangle-red');
    setIsDrawing(false);
    setStartPoint(null);
    setCurrentRect(null);
    setCanvasHistory([]);
  };

  const loadImageToCanvas = (imageSrc: string) => {
    console.log('Loading image to canvas:', imageSrc.substring(0, 50) + '...');
    
    if (!canvasRef.current || !overlayCanvasRef.current || !canvasContainerRef.current) {
      console.error('Canvas refs not available');
      return;
    }
    
    const img = new Image();
    img.onload = () => {
      console.log('Image loaded successfully:', { 
        naturalWidth: img.naturalWidth, 
        naturalHeight: img.naturalHeight 
      });
      
      const canvas = canvasRef.current!;
      const overlayCanvas = overlayCanvasRef.current!;
      const container = canvasContainerRef.current!;
      const ctx = canvas.getContext('2d')!;
      const overlayCtx = overlayCanvas.getContext('2d')!;
      
      // Calculate display size while maintaining aspect ratio
      const containerWidth = Math.min(800, container.clientWidth - 40);
      const containerHeight = 500;
      
      let displayWidth = img.naturalWidth;
      let displayHeight = img.naturalHeight;
      
      // Scale down if image is too large
      if (displayWidth > containerWidth || displayHeight > containerHeight) {
        const scaleX = containerWidth / displayWidth;
        const scaleY = containerHeight / displayHeight;
        const scale = Math.min(scaleX, scaleY);
        
        displayWidth = Math.floor(displayWidth * scale);
        displayHeight = Math.floor(displayHeight * scale);
      }
      
      console.log('Setting canvas dimensions:', { displayWidth, displayHeight });
      
      // Set canvas internal dimensions to match original image
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      overlayCanvas.width = img.naturalWidth;
      overlayCanvas.height = img.naturalHeight;
      
      // Set canvas display size
      canvas.style.width = `${displayWidth}px`;
      canvas.style.height = `${displayHeight}px`;
      overlayCanvas.style.width = `${displayWidth}px`;
      overlayCanvas.style.height = `${displayHeight}px`;
      
      // Clear and draw image
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);
      
      // Clear overlay
      overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      
      // Save initial state to history
      const initialState = canvas.toDataURL();
      setCanvasHistory([initialState]);
      
      console.log('Image successfully loaded to canvas');
    };
    
    img.onerror = (error) => {
      console.error('Failed to load image:', error);
      toast({
        title: 'Error',
        description: 'Failed to load image for editing',
        variant: 'destructive',
      });
    };
    
    img.crossOrigin = 'anonymous';
    img.src = imageSrc;
    imageRef.current = img;
  };

  const getCanvasCoordinates = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!overlayCanvasRef.current) return { x: 0, y: 0 };
    
    const canvas = overlayCanvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    
    console.log('Canvas coordinates:', { x, y, scaleX, scaleY });
    return { x, y };
  };

  const drawPreviewRect = (endX: number, endY: number) => {
    if (!overlayCanvasRef.current || !startPoint) return;
    
    const overlayCtx = overlayCanvasRef.current.getContext('2d');
    if (!overlayCtx) return;
    
    // Clear overlay
    overlayCtx.clearRect(0, 0, overlayCanvasRef.current.width, overlayCanvasRef.current.height);
    
    const width = endX - startPoint.x;
    const height = endY - startPoint.y;
    
    // Draw preview based on selected tool
    switch (selectedTool) {
      case 'rectangle-white':
        overlayCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        overlayCtx.fillRect(startPoint.x, startPoint.y, width, height);
        overlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        overlayCtx.lineWidth = 2;
        overlayCtx.setLineDash([5, 5]);
        overlayCtx.strokeRect(startPoint.x, startPoint.y, width, height);
        break;
      case 'rectangle-red':
        overlayCtx.fillStyle = 'rgba(255, 0, 0, 0.3)';
        overlayCtx.fillRect(startPoint.x, startPoint.y, width, height);
        overlayCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
        overlayCtx.lineWidth = 2;
        overlayCtx.setLineDash([5, 5]);
        overlayCtx.strokeRect(startPoint.x, startPoint.y, width, height);
        break;
      case 'rectangle-outline-red':
        overlayCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
        overlayCtx.lineWidth = 3;
        overlayCtx.setLineDash([5, 5]);
        overlayCtx.strokeRect(startPoint.x, startPoint.y, width, height);
        break;
      case 'rectangle-outline-green':
        overlayCtx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
        overlayCtx.lineWidth = 3;
        overlayCtx.setLineDash([5, 5]);
        overlayCtx.strokeRect(startPoint.x, startPoint.y, width, height);
        break;
      case 'blur':
        overlayCtx.fillStyle = 'rgba(128, 128, 128, 0.5)';
        overlayCtx.fillRect(startPoint.x, startPoint.y, width, height);
        overlayCtx.strokeStyle = 'rgba(128, 128, 128, 0.8)';
        overlayCtx.lineWidth = 2;
        overlayCtx.setLineDash([5, 5]);
        overlayCtx.strokeRect(startPoint.x, startPoint.y, width, height);
        break;
      case 'highlight':
        overlayCtx.fillStyle = 'rgba(255, 255, 0, 0.3)';
        overlayCtx.fillRect(startPoint.x, startPoint.y, width, height);
        overlayCtx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
        overlayCtx.lineWidth = 2;
        overlayCtx.setLineDash([5, 5]);
        overlayCtx.strokeRect(startPoint.x, startPoint.y, width, height);
        break;
      case 'crop':
        // Draw crop preview with dimmed outside area
        overlayCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        overlayCtx.fillRect(0, 0, overlayCanvasRef.current.width, overlayCanvasRef.current.height);
        overlayCtx.clearRect(startPoint.x, startPoint.y, width, height);
        overlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        overlayCtx.lineWidth = 2;
        overlayCtx.setLineDash([5, 5]);
        overlayCtx.strokeRect(startPoint.x, startPoint.y, width, height);
        break;
      default:
        overlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        overlayCtx.lineWidth = 2;
        overlayCtx.setLineDash([5, 5]);
        overlayCtx.strokeRect(startPoint.x, startPoint.y, width, height);
    }
    overlayCtx.setLineDash([]);
    
    console.log('Drawing preview rect:', { startPoint, endX, endY, width, height, tool: selectedTool });
  };

  const handleCanvasMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
    const coords = getCanvasCoordinates(e);
    setIsDrawing(true);
    setStartPoint(coords);
    console.log('Mouse down at:', coords);
  };

  const handleCanvasMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDrawing || !startPoint) return;
    
    const coords = getCanvasCoordinates(e);
    drawPreviewRect(coords.x, coords.y);
  };

  const handleCanvasMouseUp = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!canvasRef.current || !overlayCanvasRef.current || !isDrawing || !startPoint) return;
    
    // Save current state before applying new action
    saveCanvasState();
    
    const endCoords = getCanvasCoordinates(e);
    const ctx = canvasRef.current.getContext('2d');
    const overlayCtx = overlayCanvasRef.current.getContext('2d');
    if (!ctx || !overlayCtx) return;

    const width = endCoords.x - startPoint.x;
    const height = endCoords.y - startPoint.y;

    // Clear overlay
    overlayCtx.clearRect(0, 0, overlayCanvasRef.current.width, overlayCanvasRef.current.height);

    console.log('Drawing rectangle:', { startPoint, endCoords, width, height, tool: selectedTool });

    // Apply the selected tool to the main canvas
    switch (selectedTool) {
      case 'rectangle-white':
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.fillRect(startPoint.x, startPoint.y, width, height);
        break;
      case 'rectangle-red':
        ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
        ctx.fillRect(startPoint.x, startPoint.y, width, height);
        break;
      case 'rectangle-outline-red':
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 3;
        ctx.strokeRect(startPoint.x, startPoint.y, width, height);
        break;
      case 'rectangle-outline-green':
        ctx.strokeStyle = 'green';
        ctx.lineWidth = 3;
        ctx.strokeRect(startPoint.x, startPoint.y, width, height);
        break;
      case 'blur':
        // Apply pixelation effect for blur
        const imageData = ctx.getImageData(
          Math.min(startPoint.x, endCoords.x), 
          Math.min(startPoint.y, endCoords.y), 
          Math.abs(width), 
          Math.abs(height)
        );
        const data = imageData.data;
        const pixelSize = 8;
        
        // Create pixelated effect
        for (let y = 0; y < Math.abs(height); y += pixelSize) {
          for (let x = 0; x < Math.abs(width); x += pixelSize) {
            const pixelIndex = (y * Math.abs(width) + x) * 4;
            if (pixelIndex < data.length) {
              const r = data[pixelIndex];
              const g = data[pixelIndex + 1];
              const b = data[pixelIndex + 2];
              
              ctx.fillStyle = `rgb(${r},${g},${b})`;
              ctx.fillRect(
                Math.min(startPoint.x, endCoords.x) + x, 
                Math.min(startPoint.y, endCoords.y) + y, 
                pixelSize, 
                pixelSize
              );
            }
          }
        }
        break;
      case 'highlight':
        ctx.fillStyle = 'rgba(255, 255, 0, 0.4)';
        ctx.fillRect(startPoint.x, startPoint.y, width, height);
        break;
      case 'crop':
        // For crop, we'll create a new canvas with just the selected area
        if (imageRef.current) {
          const newCanvas = document.createElement('canvas');
          const newCtx = newCanvas.getContext('2d')!;
          newCanvas.width = Math.abs(width);
          newCanvas.height = Math.abs(height);
          
          newCtx.drawImage(
            imageRef.current,
            Math.min(startPoint.x, endCoords.x),
            Math.min(startPoint.y, endCoords.y),
            Math.abs(width),
            Math.abs(height),
            0,
            0,
            Math.abs(width),
            Math.abs(height)
          );
          
          // Replace current canvas content
          canvasRef.current.width = newCanvas.width;
          canvasRef.current.height = newCanvas.height;
          overlayCanvasRef.current.width = newCanvas.width;
          overlayCanvasRef.current.height = newCanvas.height;
          
          // Update display size
          const maxWidth = 800;
          const maxHeight = 600;
          let displayWidth = newCanvas.width;
          let displayHeight = newCanvas.height;
          
          if (displayWidth > maxWidth || displayHeight > maxHeight) {
            const ratio = Math.min(maxWidth / displayWidth, maxHeight / displayHeight);
            displayWidth *= ratio;
            displayHeight *= ratio;
          }
          
          canvasRef.current.style.width = `${displayWidth}px`;
          canvasRef.current.style.height = `${displayHeight}px`;
          overlayCanvasRef.current.style.width = `${displayWidth}px`;
          overlayCanvasRef.current.style.height = `${displayHeight}px`;
          
          ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
          ctx.drawImage(newCanvas, 0, 0);
          overlayCtx.clearRect(0, 0, overlayCanvasRef.current.width, overlayCanvasRef.current.height);
        }
        break;
    }

    setIsDrawing(false);
    setStartPoint(null);
    setCurrentRect(null);
    
    toast({
      title: 'Tool applied',
      description: `${selectedTool.replace('-', ' ')} applied successfully`,
    });
  };

  const saveEditedImage = () => {
    if (!canvasRef.current || editingImageIndex === null) return;
    
    const editedImageData = canvasRef.current.toDataURL('image/png');
    const newImages = [...images];
    newImages[editingImageIndex] = {
      ...newImages[editingImageIndex],
      data: editedImageData,
      content_type: 'image/png'
    };
    
    onChange(newImages);
    closeImageEditor();
    
    toast({
      title: 'Image saved',
      description: 'Your edited image has been saved successfully',
    });
  };

  const saveCanvasState = () => {
    if (!canvasRef.current) return;
    
    const dataURL = canvasRef.current.toDataURL();
    setCanvasHistory(prev => {
      const newHistory = [...prev, dataURL];
      // Keep only the last 10 states to prevent memory issues
      return newHistory.slice(-10);
    });
    console.log('Canvas state saved, history length:', canvasHistory.length + 1);
  };

  const undoLastAction = () => {
    if (!canvasRef.current || canvasHistory.length === 0) {
      toast({
        title: 'Nothing to undo',
        description: 'No previous actions to undo',
      });
      return;
    }

    const lastState = canvasHistory[canvasHistory.length - 1];
    setCanvasHistory(prev => prev.slice(0, -1));

    const ctx = canvasRef.current.getContext('2d');
    if (!ctx) return;

    const img = new Image();
    img.onload = () => {
      ctx.clearRect(0, 0, canvasRef.current!.width, canvasRef.current!.height);
      ctx.drawImage(img, 0, 0);
      console.log('Undo applied, remaining history length:', canvasHistory.length - 1);
    };
    img.src = lastState;

    toast({
      title: 'Action undone',
      description: 'Last drawing action has been undone',
    });
  };

  React.useEffect(() => {
    if (editingImageIndex !== null && images[editingImageIndex]) {
      console.log('Effect triggered - loading image for editing');
      // Add a small delay to ensure the dialog has rendered
      setTimeout(() => {
        loadImageToCanvas(images[editingImageIndex].data);
      }, 100);
    }
  }, [editingImageIndex, images]);

  // Global paste event listener
  React.useEffect(() => {
    const handleGlobalPaste = (e: ClipboardEvent) => {
      // Only handle paste if not focused on an input
      if (document.activeElement?.tagName !== 'INPUT' && document.activeElement?.tagName !== 'TEXTAREA') {
        handlePaste(e);
      }
    };

    document.addEventListener('paste', handleGlobalPaste);
    return () => document.removeEventListener('paste', handleGlobalPaste);
  }, [handlePaste]);

  return (
    <div className={cn("space-y-4", className)}>
      <Label>{title}</Label>
      
      {/* Upload Area */}
      <div
        className={cn(
          "border-2 border-dashed rounded-lg p-8 text-center transition-colors cursor-pointer",
          dragActive 
            ? "border-primary bg-primary/10"
            : "border-muted-foreground/25 hover:border-primary/50"
        )}
        onDragEnter={handleDrag}
        onDragOver={handleDrag}
        onDragLeave={handleDrag}
        onDrop={handleDrop}
        onPaste={handlePaste}
        tabIndex={0}
      >
        <div className="flex flex-col items-center justify-center space-y-3">
          <div className="flex items-center space-x-2">
            <Upload className="w-8 h-8 text-muted-foreground" />
            <ClipboardPaste className="w-6 h-6 text-muted-foreground" />
          </div>
          <div className="space-y-1">
            <p className="text-sm font-medium">
              Drag & drop images here or paste (Ctrl+V)
            </p>
            <p className="text-xs text-muted-foreground">
              Supports: JPG, PNG, GIF, WEBP
            </p>
          </div>
          <div className="flex gap-2">
            <Button 
              type="button" 
              variant="outline" 
              size="sm"
              onClick={() => fileInputRef.current?.click()}
            >
              <ImageIcon className="w-4 h-4 mr-2" />
              Browse Files
            </Button>
          </div>
        </div>
        
        <Input
          ref={fileInputRef}
          type="file"
          accept="image/*"
          onChange={handleFileChange}
          multiple
          className="hidden"
        />
      </div>

      {/* Image Gallery */}
      {images.length > 0 && (
        <div className="space-y-3">
          <p className="text-sm text-muted-foreground">Uploaded Images ({images.length})</p>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {images.map((image, index) => (
              <div key={index} className="relative border rounded-lg overflow-hidden group">
                <div className="aspect-video relative">
                  <img 
                    src={image.data} 
                    alt={image.label || `Image ${index + 1}`}
                    className="object-cover w-full h-full cursor-pointer"
                    onClick={() => openImageEditor(index)}
                  />
                  <Button
                    type="button"
                    variant="destructive"
                    size="sm"
                    className="absolute top-2 right-2 h-6 w-6 p-0 opacity-0 group-hover:opacity-100 transition-opacity"
                    onClick={() => removeImage(index)}
                  >
                    <X className="h-4 w-4" />
                  </Button>
                  <Badge className="absolute top-2 left-2 opacity-0 group-hover:opacity-100 transition-opacity">
                    Click to edit
                  </Badge>
                </div>
                <div className="p-3 border-t">
                  <Input
                    value={image.label || ''}
                    onChange={(e) => updateImageLabel(index, e.target.value)}
                    placeholder={`Figure ${index + 1}: Enter description`}
                    className="text-sm"
                  />
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Image Editor Dialog */}
      <Dialog open={editingImageIndex !== null} onOpenChange={closeImageEditor}>
        <DialogContent className="max-w-5xl max-h-[90vh] overflow-auto">
          <DialogHeader>
            <DialogTitle>Edit Image</DialogTitle>
          </DialogHeader>
          
          <div className="space-y-4">
            {/* Tool Selection */}
            <div className="flex flex-wrap gap-2 items-center">
              {annotationTools.map((tool) => (
                <Button
                  key={tool.id}
                  type="button"
                  variant={selectedTool === tool.id ? 'default' : 'outline'}
                  size="sm"
                  onClick={() => setSelectedTool(tool.id)}
                  className="flex items-center gap-2"
                >
                  <tool.icon className="w-4 h-4" />
                  {tool.name}
                </Button>
              ))}
              
              {/* Undo Button */}
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={undoLastAction}
                disabled={canvasHistory.length === 0}
                className="flex items-center gap-2 ml-4"
                title="Undo last action"
              >
                <Undo className="w-4 h-4" />
                Undo
              </Button>
            </div>

            {/* Canvas Container */}
            <div 
              ref={canvasContainerRef}
              className="border rounded-lg overflow-hidden bg-gray-50 relative min-h-[400px] flex items-center justify-center"
            >
              <div className="relative">
                <canvas
                  ref={canvasRef}
                  className="block max-w-full h-auto border"
                  style={{ maxHeight: '60vh' }}
                />
                <canvas
                  ref={overlayCanvasRef}
                  className={cn("absolute top-0 left-0 block max-w-full h-auto", {
                    'cursor-crosshair': selectedTool !== 'crop',
                    'cursor-crop': selectedTool === 'crop'
                  })}
                  onMouseDown={handleCanvasMouseDown}
                  onMouseMove={handleCanvasMouseMove}
                  onMouseUp={handleCanvasMouseUp}
                  style={{ maxHeight: '60vh', pointerEvents: 'auto' }}
                />
              </div>
            </div>

            {/* Instructions */}
            <div className="text-sm text-muted-foreground bg-muted p-3 rounded">
              <p>
                <strong>Instructions:</strong> Select a tool above, then click and drag on the image to apply the effect. 
                Use the rectangle tools to highlight areas, blur tool to pixelate sensitive information, 
                highlight tool to mark important sections, and crop tool to trim the image. Use the Undo button to revert the last action.
              </p>
            </div>

            {/* Actions */}
            <div className="flex justify-end gap-2">
              <Button type="button" variant="outline" onClick={closeImageEditor}>
                Cancel
              </Button>
              <Button type="button" onClick={saveEditedImage}>
                Save Changes
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default EnhancedImageUploader;